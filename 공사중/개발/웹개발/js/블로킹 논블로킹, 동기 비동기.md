

5단 분석법

블로킹 (Blocking)

논블로킹 (Non-Blocking)

동기 (Synchronous)

비동기 (Asynchoronous)

블로킹, 논블로킹, 동기, 비동기의 정의

블로킹, 논블로킹

일반 명사

고유 명사

서로의 작업에 차단을 할 수 있냐!

블로킹(Blockling)

논블로킹(Non-blocking)

서로의 작업을 순서대로 해야 하냐!

동기(Synchronous)

비동기(Asynchronous)

동기, 비동기

일반 명사

고유 명사

사용 이유

블로킹, 논블로킹

동기, 비동기

사용 방법

블로킹, 논블로킹

블로킹 (Blocking)

논블로킹 (Non-Blocking)

동기, 비동기

동기 (Synchronous)

비동기 (Asynchronous)

블로킹 논블로킹, 동기 비동기 표로 정리

동기 / 블로킹

동기 / 논블로킹

비동기 / 블로킹

비동기 / 논블로킹

알면 좋은 정보

실행 컨텍스트와 비동기 처리

## 5단 분석법

#### 블로킹 (Blocking)

특정 작업(예: I/O)이 완료될 때까지 프로그램의 실행이 멈추는 상태

|   |   |   |   |
|---|---|---|---|
|순서|분석|단어|내용|
|1|일반 명사|블로킹|막다, 차단하다|
|2|고유 명사|블로킹|현재 실행 중인 작업이 완료될 때까지 다음 작업을 기다리는 방식|
|3|사용 이유|블로킹|작업의 완료와 순차적 실행을 보장하여 프로그램의 실행 흐름을 쉽게 관리하기 위해서|
|4|사용 방법|블로킹|동기적 API 호출을 통해 구현, 작업 완료 후 다음 명령어로 넘어감|
|5|다른 기술과의 비교|블로킹|-|

#### 논블로킹 (Non-Blocking)

순차적으로 일하지 않고

|   |   |   |   |
|---|---|---|---|
|순서|분석|단어|내용|
|1|일반 명사|논블로킹|막지 않다, 차단하지 않다|
|2|고유 명사|논블로킹|현재 실행중인 작업의 완료를 기다리지 않고 다음 작업을 실행하는 방식|
|3|사용 이유|논블로킹|시스템 자원의 효율적 사용 비동기적 작업 처리를 통해 프로그램의 반응성과 처리 능력을 향상시키기 위해서|
|4|사용 방법|논블로킹|비동기적 API 호출, 콜백 함수, 프로미스, async/await 등을 이용해 구현, 작업 요청 후 바로 다음 명령어 실행|
|5|다른 기술과의 비교|논블로킹|-|

#### 동기 (Synchronous)

다른 애한테 일시키고 기다린다.

|   |   |   |   |
|---|---|---|---|
|순서|분석|단어|내용|
|1|일반 명사|동기|두 개 이상의 다른 것들을 동일하게 유지시키는 것|
|2|고유 명사|동기|함수 호출 시 결과가 반환될 때까지 기다리는 처리 방식|
|3|사용 이유|동기|실행 순서가 보장되며, 프로그램의 흐름을 이해하고 디버깅하기 쉬움|
|4|사용 방법|동기|동기적 API 호출을 통해 구현, 작업 완료 후 다음 명령어로 넘어감|
|5|다른 기술과의 비교|비동기|-|

#### 비동기 (Asynchoronous)

다른 애한테 일시키고 내 일한다.

|     |            |     |                                                                    |
| --- | ---------- | --- | ------------------------------------------------------------------ |
| 순서  | 분석         | 단어  | 내용                                                                 |
| 1   | 일반 명사      | 비동기 | 두 개 이상의 다른 것들을 동일하게 유지시키지 않는 것                                     |
| 2   | 고유 명사      | 비동기 | 함수 호출과 결과 반환 사이에 다른 작업을 수행할 수 있는 처리 방식                             |
| 3   | 사용 이유      | 비동기 | 시스템 자원의 비효율적 사용을 줄이고, 대기 시간 없이 여러 작업을 병렬로 처리할 수 있음                 |
| 4   | 사용 방법      | 비동기 | 콜백 함수, 프로미스(Promise), async/await 등을 활용하여 결과를 나중에 받음, 동시에 여러 작업 가능 |
| 5   | 다른 기술과의 비교 | 동기  | -                                                                  |

## 블로킹, 논블로킹, 동기, 비동기의 정의

### 블로킹, 논블로킹

#### 일반 명사

|   |   |
|---|---|
|블로킹|막다, 차단하다|
|논블로킹|막지 않다, 차단하지 않다|

블로킹의 일반 명사는 “막다, 차단하다” 입니다.

논블로킹의 일반 명사는 “막지 않다, 차단하지 않다” 입니다.

고유 명사를 한 번 살펴볼까요?

#### 고유 명사

|   |   |
|---|---|
|블로킹|현재 실행 중인 작업이 완료될 때까지 다음 작업을 기다리는 방식|
|논블로킹|현재 실핼 중인 작업의 완료를 기다리지 않고 다음 작업을 실행하는 방식|

블로킹의 고유 명사는 “현재 실행 중인 작업이 완료될 때까지 다음 작업을 기다리는 방식” 입니다.

논블로킹의 고유 명사는 “현재 실핼 중인 작업의 완료를 기다리지 않고 다음 작업을 실행하는 방식” 입니다.

void와 yaro가 협업하여 곰인형 눈을 붙이는 아르바이트를 진행하는 예시로 설명드리겠습니다.

void는 곰인형의 눈을 붙이고, yaro는 눈이 붙여진 곰인형을 상자에 넣는 작업을 합니다.

#### 서로의 작업에 차단을 할 수 있냐!

#### 블로킹(Blockling)

블로킹 상황에서는 Void가 곰인형의 눈을 붙이고, 그 작업이 완전히 끝날 때까지 Yaro는 포장 작업을 시작할 수 없습니다. 더 나아가, Void 또한 Yaro가 포장을 완료하기 전까지 다음 곰인형의 눈을 붙이기 시작할 수 없습니다. 즉, 각 작업이 이전 작업의 완전한 종료를 기다리며, 그 사이 프로그램은 해당 작업 완료를 기다리는 동안 다른 작업을 수행하지 못하고 대기합니다. 이는 작업 처리 흐름이 중단되는 것을 의미합니다.

#### 논블로킹(Non-blocking)

논블로킹 상황에서는 Void가 곰인형의 눈을 붙인 후, Yaro가 아직 포장을 완료하지 않았더라도 다음 곰인형의 눈을 계속해서 붙일 수 있습니다. 마찬가지로 Yaro는 Void가 눈을 붙일 때까지 기다리지 않고, 이미 눈이 붙여진 곰인형이 있으면 바로 포장 작업을 진행할 수 있습니다. 이 경우, 각자의 작업은 서로의 진행 상황에 영향을 받지 않으며 독립적으로 계속 진행됩니다.

즉, ‘서로 업무를 차단할 수 있는가?’가 중요.

#### 서로의 작업을 순서대로 해야 하냐!

#### 동기(Synchronous)

동기 방식에서는 void의 작업(곰인형에 눈을 붙이는 것)과 yaro의 작업(상자에 넣고 포장하는 것)이 순차적으로 진행됩니다. 이 맥락에서, Void는 곰인형에 눈을 붙이고, 그 작업이 완료되어야만 yaro가 포장 작업을 시작할 수 있습니다. 즉, yaro의 작업 시작은 void의 작업 완료에 의존적입니다. 각 단계는 이전 단계가 완전히 끝나야만 다음 단계로 넘어갈 수 있으므로, 전체 작업 흐름이 한 작업의 완료를 기다리며 진행됩니다.

#### 비동기(Asynchronous)

비동기 방식에서는 void와 yaro의 작업이 독립적으로 진행됩니다. void가 곰인형에 눈을 붙이는 동안, yaro는 기다리지 않고 이미 눈이 붙어 준비된 곰인형을 포장할 수 있습니다. 만약 void의 작업이 완료되기 전에 yaro가 모든 준비된 곰인형을 포장했다면, yaro는 다음 곰인형이 준비될 때까지 다른 작업을 할 수 있습니다. void와 yaro는 각자의 작업 완료 시점에 서로에게 알림(예를 들어, 완성된 곰인형을 전달하는 행위)을 줄 수 있으며, 이 알림을 통해 다음 작업을 계속하거나 시작할 수 있습니다.

즉, ‘서로 업무를 순차적으로 할 수 있는가?’가 중요.

### 동기, 비동기

#### 일반 명사

|   |   |
|---|---|
|동기|두 개 이상의 다른 것들을 동일하게 유지시키는 것|
|비동기|두 개 이상의 다른 것들을 동일하게 유지시키지 않는 것|

동기의 일반 명사는 “두 개 이상의 다른 것들을 동일하게 유지시키는 것” 입니다.

비동기의 일반 명사는 “두 개 이상의 다른 것들을 동일하게 유지시키지 않는 것” 입니다.

#### 고유 명사

|   |   |
|---|---|
|동기|함수 호출 시 결과가 반환될 때까지 기다리는 처리 방식|
|비동기|함수 호출과 결과 반환 사이에 다른 작업을 수행할 수 있는 처리 방식|

동기의 고유 명사는 “함수 호출 시 결과가 반환될 때까지 기다리는 처리 방식” 입니다.

비동기의 고유 명사는 “함수 호출과 결과 반환 사이에 다른 작업을 수행할 수 있는 처리 방식” 입니다.

블로킹, 논블로킹은 “현재 작업이 다른 작업의 실행을 차단 하는가”의 차이라고 생각하시면 되고,

동기, 비동기는 “현재 작업과 다음 작업이 순서 대로 실행 되는가”의 차이라고 생각하시면 됩니다.

블로킹, 논블로킹과 동기, 비동기는 모두 프로그램이 어떻게 작업을 처리할지 결정하는 방식을 의미합니다.

이런 방식들은 프로그램이 어떤 작업을 할지, 언제 할지 결정할 수 있는 '제어권'과 밀접하게 연결되어 있습니다.

제어권이란, 프로그램이 스스로 작업의 실행 순서와 방식을 결정할 수 있는 권한을 의미합니다.

리모컨을 사용해 TV 채널을 바꾸는 것처럼, 프로그램도 제어권을 통해 어떤 작업을 수행할지, 어떤 자원을 사용할지를 결정하게 됩니다.

정리하자면, 제어권은 프로그램 실행 중 시스템 자원, 데이터 처리 등의 작업을 관리하는 권한입니다.

제어권이 없으면 아무것도 할 수가 없습니다.

## 사용 이유

### 블로킹, 논블로킹

|   |   |
|---|---|
|블로킹|작업의 완료와 순차적 실행을 보장하여 프로그램의 실행 흐름을 쉽게 관리하기 위해서|
|논블로킹|시스템 자원의 효율적 사용 비동기적 작업 처리를 통해 프로그램의 반응성과 처리 능력을 향상시키기 위해서|

블로킹을 사용하는 이유는 “작업의 완료와 순차적 실행을 보장하여 프로그램의 실행 흐름을 쉽게 관리하기 위해서” 입니다.

논블로킹을 사용하는 이유는 “시스템 자원의 효율적 사용 비동기적 작업 처리를 통해 프로그램의 반응성과 처리 능력을 향상시키기 위해서” 입니다.

### 동기, 비동기

|   |   |
|---|---|
|동기|실행 순서가 보장되며, 프로그램의 흐름을 이해하고 디버깅하기 쉬움|
|비동기|시스템 자원의 비효율적 사용을 줄이고, 대기 시간 없이 여러 작업을 병렬로 처리할 수 있음|

동기를 사용하는 이유는 “실행 순서가 보장되며, 프로그램의 흐름을 이해하고 디버깅하기 쉬움” 입니다.

비동기를 사용하는 이유는 “시스템 자원의 비효율적 사용을 줄이고, 대기 시간 없이 여러 작업을 병렬로 처리할 수 있음” 입니다.

## 사용 방법

### 블로킹, 논블로킹

|   |   |
|---|---|
|블로킹|동기적 API 호출을 통해 구현, 작업 완료 후 다음 명령어로 넘어감|
|논블로킹|비동기적 API 호출, 콜백 함수, 프로미스, async/await 등을 이용해 구현, 작업 요청 후 바로 다음 명령어 실행|

블로킹을 사용하는 방법은 “동기적 API 호출을 통해 구현, 작업 완료 후 다음 명령어로 넘어감” 입니다.

논블로킹을 사용하는 방법은 “비동기적 API 호출, 콜백 함수, 프로미스, async/await 등을 이용해 구현, 작업 요청 후 바로 다음 명령어 실행” 입니다.

•

제어권

◦

어떤 프로세스나 스레드가 프로그램의 실행 흐름을 관리하고 결정할 수 있는 권한을 의미합니다

◦

즉, 코드를 실행할 권리

•

결과 처리(Result Handling)

◦

작업의 결과를 어떻게 처리할 것인가를 다루는 과정을 의미합니다.

#### 블로킹 (Blocking)

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2Ff6844e44-9cb6-42e0-b7f0-6328353a5b04%2FUntitled.png&blockId=4f9238fc-1c8a-4847-9f1c-4f87941642b3)

•

특정 작업을 실행 할 때 제어권을 완전히 넘기는 방식

•

제어권이 넘어 갔기 때문에, 다른 작업을 진행할 수 없음.

const fs = require('fs'); const data = fs.readFileSync('./file_path'); conssole.log('파일 읽기 완료', data);

JavaScript

복사

•

fs.readFileSync 호출시 제어권이 파일 시스템(fs)에게 전달됨.

◦

제어권이 넘어 갔기 때문에, 그동안 다른 작업을 수행할수 없음 ⇒ Block

•

파일 읽기가 완료되면 fs.readFileSync 가 제어권을 반환

◦

제어권이 반환 되었기 때문에 그 다음 작업 진행이 가능.

#### 논블로킹 (Non-Blocking)

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2F856af1e2-c6ea-464a-99c0-c829e3db8bbe%2FUntitled.png&blockId=e15ebd26-f57d-4900-a5e7-63aa46e64185)

•

특정 작업 실행시 제어권을 넘겨 실행 후 즉시 돌려 받는 형태

•

작업이 진행되는 동안 백그라운드에서 다른 작업이 진행

•

제어권을 돌려 받기 때문에 다른 작업을 수행할 수 있음.

const fs = require('fs'); fs.readFile('./file_path', (err, data) => { if(err) return err; console.log('파일 읽기 완료', data); })

JavaScript

복사

•

fs.readFile 호출시 제어권을 넘겨 실행후 즉시 제어권 반환

◦

제어권을 반환 받았기 때문에 다른 작업 수행이 가능 ⇒ Non-Block

•

파일 읽기가 완료 되면 fs.readFile 에 등록된 callback 을 호출.

### 동기, 비동기

|   |   |
|---|---|
|동기|API 호출이나 함수 실행 시 결과를 바로 반환받음|
|비동기|콜백 함수, 프로미스(Promise), async/await 등을 활용하여 결과를 나중에 받음, 동시에 여러 작업 가능|

동기를 사용하는 방법은 “API 호출이나 함수 실행 시 결과를 바로 반환받음” 입니다.

비동기를 사용하는 방법은 “콜백 함수, 프로미스(Promise), async/await 등을 활용하여 결과를 나중에 받음, 동시에 여러 작업 가능” 입니다.

#### 동기 (Synchronous)

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2F1ff60899-7160-4c64-8aca-de4b14f73c7b%2FUntitled.png&blockId=1e85c83c-67e4-44d4-99ea-e1a278a1164c)

•

특정 작업이 완료 될 때까지 기다리는 방식.

•

제어권은 특정 작업 실행 이후 즉시 돌려 받는 형태.

function doWorkSync() { const start = Date.now(); while (Date.now() < start + 1000); console.log('동기 작업 완료'); } console.log('작업 시작'); doWorkSync(); console.log('다음 작업');

JavaScript

복사

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2Fa321c265-d702-4303-b63a-882054205ef9%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-04-21_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_3.50.52.png&blockId=a19c1b6a-5cbb-47ee-8525-0aadc53df7f8)

•

doWorkSync 에게 제어권을 넘겨 실행 후 즉시 제어권 반환

◦

doWorkSync 가 종료 될 때까지 대기.

◦

종료 이후 다음 작업 실행

#### 비동기 (Asynchronous)

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2Fe4da4a80-5bfe-480b-96f6-5f01163a3695%2FUntitled.png&blockId=9bc0de02-3722-4ecf-a306-47d34bff057f)

•

특정 작업에 대한 진행 상황, 결과 처리를 제어권이 신경 쓰지 않음.

•

비동기 직업 이후 결과 처리를 해야 한다면?

◦

기존 작업 진행하고 있는게 있다면 처리후 진행

function doWorkAsync() { setTimeout(() => { console.log('비동기 작업 완료'); }, 1000); } console.log('작업 시작'); doWorkAsync(); console.log('다음 작업');

JavaScript

복사

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2Fce850fb6-b32e-4945-af53-f378ee8a2ad7%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-04-21_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_3.49.18.png&blockId=dd22d174-5eb5-4e4d-9158-55349e2333d8)

•

doWorkAsync 에게 제어권을 넘겨 실행 후 즉시 제어권 반환

◦

doWorkAsync 가 작업이 끝났다고 통보

•

제어권은 현재 진행중인 작업이 있을 경우 해당 작업을 끝내고 doWorkAsync 결과에 대한 작업을 진행

## 블로킹 논블로킹, 동기 비동기 표로 정리

|   |   |   |
|---|---|---|
||블로킹 (Blocking)|논블로킹 (Non-Blocking)|
|동기 (Sync)|블로킹 / 동기|논블로킹 / 동기|
|비동기 (Async)|블로킹 / 비동기|논블로킹 / 비동기|

1.

void가 눈을 붙인다.

2.

yaro가 상자에 넣는다.

3.

void가 포장한다.

### 동기 / 블로킹

시나리오:

1.

Void가 곰인형에 눈을 붙입니다.

2.

완료되기 전까지 Yaro는 포장 작업을 시작할 수 없습니다. Void의 작업이 끝나면 Yaro에게 곰인형을 전달하고 Yaro는 포장을 시작합니다.

3.

Yaro가 포장을 완료할 때까지 기다린 후, Void는 다음 곰인형에 눈을 붙입니다.

•

제어권: Void의 첫 번째 작업 완료 후 Yaro로 넘어가고, Yaro의 포장 완료 후 다시 Void로 넘어갑니다. 이 과정에서 각 작업의 시작은 이전 작업의 완료를 필요로 합니다.

•

결과 처리: 각 단계의 결과가 다음 단계의 시작을 직접적으로 결정합니다. Yaro는 Void의 결과를 받아 포장을 시작하고, Void는 Yaro의 포장 완료 결과를 기다린 후 다음 곰인형 작업을 진행합니다.

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2F95ee2d10-09c4-47d8-bac7-e43c3c5a01c9%2FUntitled.png&blockId=88b2f199-89e8-4572-8405-706a236f3f3f)

•

제어권과 결과 처리 순서가 동일한 방식.

### 동기 / 논블로킹

시나리오:

1.

Void는 계속해서 곰인형에 눈을 붙이며, 붙인 인형을 Yaro에게 전달합니다.

2.

Yaro는 Void가 눈을 붙이는 작업에 기다리지 않고 독립적으로 포장을 준비하지만, 포장 시작 시점은 Void가 곰인형을 전달할 때 결정됩니다.

3.

Void는 Yaro의 포장 작업이 끝나기를 기다리지 않고, 다음 곰인형에 눈을 붙이기 시작합니다.

•

제어권: 제어권은 분산되어 있습니다. Void는 자신의 작업을 계속 수행하고, Yaro는 자신의 작업을 독립적으로 진행합니다.

•

결과 처리: 포장 작업의 시작은 Void가 곰인형을 전달하는 시점에 동기적으로 결정됩니다. Void는 결과를 기다리지 않고 다음 작업을 진행합니다.

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2F85049e65-1082-4628-889e-ee7eb66e02f8%2FUntitled.png&blockId=006d0c76-97a7-4912-82ca-e6ba2411c277)

•

제어권은 실행 즉시 반환

•

결과처리에 대해서 지속적인 관찰

•

결과가 완료 되었을 때 해당 처리를 진행

### 비동기 / 블로킹

시나리오:

1.

Void가 곰인형에 눈을 붙이고 완료되면 바로 Yaro에게 전달합니다.

2.

Yaro는 포장 작업을 시작하고, Void는 다음 곰인형에 눈을 붙일 수 없습니다.

3.

Yaro가 포장을 마치면, 완료된 곰인형을 Void에게 알립니다. Void는 그제서야 다음 곰인형 작업을 시작할 수 있습니다.

•

제어권: 제어권은 단계적으로 넘어갑니다. Void는 자신의 작업을 마친 후 Yaro에게 인계하며, Yaro의 작업 완료까지 Void는 다음 작업을 시작할 수 없습니다. 이는 Yaro의 작업 완료를 Void가 기다려야 하는 블로킹 상황을 만듭니다.

•

결과 처리: Yaro의 포장 완료 결과는 Void가 다음 작업을 시작하기 전에 반드시 확인해야 합니다. 이는 동기적으로 처리되며, 하나의 작업 결과가 다음 작업의 시작을 직접적으로 결정합니다.

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2F2ac7f949-8284-45d8-80eb-3b408488ee54%2FUntitled.png&blockId=4febc2a2-4508-4e58-8878-7fff80cdac0d)

•

제어권은 실행 즉시 반환

•

결과 처리가 나올 때 까지 다른 작업을 하지 않음.

•

실제로는 이런 방식이 거의 없음

### 비동기 / 논블로킹

시나리오:

1.

Void는 지속적으로 곰인형에 눈을 붙이며 완료된 인형을 Yaro에게 전달합니다.

2.

Yaro는 Void의 작업 완료 여부와 무관하게 준비된 곰인형을 포장합니다.

3.

Void는 Yaro의 포장 완료를 기다리지 않고 새로운 곰인형에 눈을 붙입니다.

•

제어권: 제어권은 완전히 분산되어 있습니다. 각자는 자신의 작업을 독립적으로 관리하며, 다른 사람의 작업 진행 상황에 영향을 받지 않습니다.

•

결과 처리: 결과 처리도 완전히 독립적입니다. 각자의 작업 결과는 다른 사람의 작업에 영향을 주지 않으며, 완료 시 서로에게 통지할 수 있습니다.

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2Fd37f10e8-3872-464a-ba03-2002ef06a94d%2FUntitled.png&blockId=1f827e54-ebf1-4923-8e98-5f4632aef51a)

•

제어권 실행 즉시 반환

•

결과에 관계 없이 자신의 작업 진행.

•

결과 처리를 요청 받으면 현재 작업을 마무리후 해당 결과 처리 작업을 진행

## 알면 좋은 정보

#### 실행 컨텍스트와 비동기 처리

•

자바스크립트는 싱글 스레드 방식

•

한번의 하나의 CallStack만 처리 가능.

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fcf024025-486d-4514-84ae-3a7c5951c17c%2F6d5f0cb2-cb0e-4c6a-969a-f919a80c1e00%2FUntitled.png&blockId=39b25a91-b398-4483-a9ea-09390eb79d66)

1.

CallStack 에 비동기 setTimeout 컨텍스트가 쌓임.

2.

WebAPI 에게 setTimeout 컨텍스트 전달.

a.

비동기 작업 진행 (3초 대기)

3.

Func b 컨텍스트 CallStack 쌓인 후 진행

4.

Func c 컨텍스트 CallStack 쌓인 후 진행

a.

WebAPI가 3초가 지난후 setTimeount 컨텍스트를 TaskQueue 로 전달.

b.

EventLoop 가 CallStack 과 TaskQueue를 지속적으로 감시 하면서 CallStack이 비어 있을 때 TaskQueue에 있는 setTimeout 컨텍스트를 CallStack으로 전달.

c.

setTimeout 컨텍스트 CallStack 쌓인 후 진행

Today

1

- 0초 전